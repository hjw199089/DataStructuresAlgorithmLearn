=========二叉树基本算法=====
基础知识:
二叉树第i层商家节点数最多2^(i-1)
高度为k的二叉树最多2^k - 1个节点
二叉树，n0，n1，n2分别表示度为0、1、2的节点的个数，有n0 = n2 + 1
满二叉树，高度为k且2^k - 1个节点
完全二叉树，只有最底层最左边的节点度小于2
完全二叉树：若二叉树的高度是h，除第h层之外，其他（1~h-1）层的节点数都达到了最大个数，并且第h层的节点都连续的集中在最左边。想到点什么没？实际上，完全二叉树和堆联系比较紧密哈~~~
满二叉树：除最后一层外，每一层上的所有节点都有两个子节点，最后一层都是叶子节点。
哈夫曼树：又称为最有数，这是一种带权路径长度最短的树。哈夫曼编码就是哈夫曼树的应用。
平衡二叉树：所谓平衡二叉树指的是，左右两个子树的高度差的绝对值不超过 1。
红黑树：红黑树是每个节点都带颜色的树，节点颜色或是红色或是黑色，红黑树是一种查找树。红黑树有一个重要的性质，从根节点到叶子节点的最长的路径不多于最短的路径的长度的两倍。对于红黑树，插入，删除，查找的复杂度都是O（log N）。


BinTree代码中实现了如下算法:
代码地址：gitHub
【1】二叉树相关算法学习
08-26周末
3种遍历的递归方法
3种遍历的非递归方法
层次遍历
树的深度
求二叉树中叶子节点的个数
镜像二叉树
判断一个节点是否在树中+进阶判断一棵树是否是另一颗数的子树
打印到某个节点的路径
查找二叉树中两个节点的最低祖先节点（或最近公共父节点等）---递归法
查找二叉树中两个节点的最低祖先节点（或最近公共父节点等）---非递归解法
从根节点开始找到所有路径，使得路径上的节点值和为某一数值（路径不一定以叶子节点结束）
二叉树第k层的节点个数
求任意两节点距离
以前序和中序遍历打印后续遍历
以前序和中序遍历重建二叉树
08-28
二叉树节点最远距离
判断是否是平衡二叉树-深度法
判断是否是平衡二叉树-直接法
判定完全二叉树
求节点数
判断是否满二叉树
0829
判断是搜索二叉树
二分查找树转化为排序的循环双链表
0830
给定一个升序排列的有序单链表，将其转换为一棵平衡的二叉搜索树
树的宽度
待续。。。


http://blog.csdn.net/laojiu_/article/details/50820749
https://www.61mon.com/index.php/archives.html
不使用递归和栈遍历二叉树；
http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/27/2659163.html
判断先序遍历和后序遍历数组的合理性
最大节点和最小节点间的路径长度





